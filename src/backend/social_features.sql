-- Create profiles table
create table if not exists public.profiles (
  id uuid references auth.users on delete cascade not null primary key,
  username text,
  avatar_url text,
  updated_at timestamp with time zone
);

-- Backfill profiles for existing users (Important for FK constraints)
insert into public.profiles (id, username, avatar_url)
select id, raw_user_meta_data->>'full_name', raw_user_meta_data->>'avatar_url'
from auth.users
on conflict (id) do nothing;

-- Set up Row Level Security (RLS) for profiles
alter table public.profiles enable row level security;

drop policy if exists "Public profiles are viewable by everyone." on profiles;
create policy "Public profiles are viewable by everyone."
  on profiles for select
  using ( true );

drop policy if exists "Users can insert their own profile." on profiles;
create policy "Users can insert their own profile."
  on profiles for insert
  with check ( auth.uid() = id );

drop policy if exists "Users can update own profile." on profiles;
create policy "Users can update own profile."
  on profiles for update
  using ( auth.uid() = id );

-- Create likes table
create table if not exists public.likes (
  id bigint generated by default as identity primary key,
  record_id bigint references public.map_records(id) on delete cascade not null,
  user_id uuid references public.profiles(id) on delete cascade not null, -- Changed to reference profiles
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  unique(record_id, user_id)
);

-- Fix likes relationship (Force update constraint if exists)
do $$
begin
  if exists (
    select 1 from information_schema.table_constraints 
    where constraint_name = 'likes_user_id_fkey'
    and table_name = 'likes'
  ) then
    alter table public.likes drop constraint likes_user_id_fkey;
  end if;

  alter table public.likes
    add constraint likes_user_id_fkey
    foreign key (user_id)
    references public.profiles(id)
    on delete cascade;
end $$;

alter table public.likes enable row level security;

drop policy if exists "Likes are viewable by everyone." on likes;
create policy "Likes are viewable by everyone."
  on likes for select
  using ( true );

drop policy if exists "Authenticated users can insert likes." on likes;
create policy "Authenticated users can insert likes."
  on likes for insert
  with check ( auth.role() = 'authenticated' );

drop policy if exists "Users can delete their own likes." on likes;
create policy "Users can delete their own likes."
  on likes for delete
  using ( auth.uid() = user_id );

-- Create comments table
create table if not exists public.comments (
  id bigint generated by default as identity primary key,
  record_id bigint references public.map_records(id) on delete cascade not null,
  user_id uuid references public.profiles(id) on delete cascade not null, -- Changed to reference profiles
  content text not null,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Fix comments relationship (Force update constraint if exists)
do $$
begin
  -- Drop old constraint if it exists (might be pointing to auth.users)
  if exists (
    select 1 from information_schema.table_constraints 
    where constraint_name = 'comments_user_id_fkey'
    and table_name = 'comments'
  ) then
    alter table public.comments drop constraint comments_user_id_fkey;
  end if;

  -- Add correct constraint pointing to profiles
  alter table public.comments
    add constraint comments_user_id_fkey
    foreign key (user_id)
    references public.profiles(id)
    on delete cascade;
end $$;

alter table public.comments enable row level security;

drop policy if exists "Comments are viewable by everyone." on comments;
create policy "Comments are viewable by everyone."
  on comments for select
  using ( true );

drop policy if exists "Authenticated users can insert comments." on comments;
create policy "Authenticated users can insert comments."
  on comments for insert
  with check ( auth.role() = 'authenticated' );

drop policy if exists "Users can delete their own comments." on comments;
create policy "Users can delete their own comments."
  on comments for delete
  using ( auth.uid() = user_id );

-- Update map_records table to support multiple images
alter table public.map_records add column if not exists images text[];

-- Fix map_records relationship for Supabase joins
-- We add a foreign key to profiles so we can select(*, profiles(*))
do $$
begin
  if not exists (
    select 1 from information_schema.table_constraints 
    where constraint_name = 'map_records_user_id_fkey_profiles'
  ) then
    alter table public.map_records
      add constraint map_records_user_id_fkey_profiles
      foreign key (user_id)
      references public.profiles(id)
      on delete cascade;
  end if;
end $$;

-- Update map_records RLS to allow viewing by everyone (for social map)
drop policy if exists "Users can view their own map records" on map_records;
drop policy if exists "Map records are viewable by everyone" on map_records;
create policy "Map records are viewable by everyone"
  on map_records for select
  using ( true );

-- Ensure insert/update/delete is still restricted to owner
drop policy if exists "Users can insert their own map records" on map_records;
create policy "Users can insert their own map records"
  on map_records for insert
  with check ( auth.uid() = user_id );

drop policy if exists "Users can update their own map records" on map_records;
create policy "Users can update their own map records"
  on map_records for update
  using ( auth.uid() = user_id );

drop policy if exists "Users can delete their own map records" on map_records;
create policy "Users can delete their own map records"
  on map_records for delete
  using ( auth.uid() = user_id );

-- Trigger to create profile on signup
create or replace function public.handle_new_user()
returns trigger as $$
begin
  insert into public.profiles (id, username, avatar_url)
  values (new.id, new.raw_user_meta_data->>'full_name', new.raw_user_meta_data->>'avatar_url');
  return new;
end;
$$ language plpgsql security definer;

drop trigger if exists on_auth_user_created on auth.users;
create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();
